<?xml version="1.0" encoding="utf-8"?>
<CodeSnippets xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="http://schemas.microsoft.com/VisualStudio/2005/CodeSnippet">
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Line2D</Title>
      <Shortcut>line</Shortcut>
      <Description>線分</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">struct Line
{
    public Vector a;
    public Vector b;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Line(Vector a, Vector b) { this.a = a; this.b = b; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector? Cross(Line a, Line b, bool allowOutOfRegion = true)
    {
        double delta = (a.b.x - a.a.x) * (b.b.y - b.a.y) - (a.b.y - a.a.y) * (b.b.x - b.a.x);
        if (delta == 0) return null;
        double ramda = ((b.b.y - b.a.y) * (b.b.x - a.a.x) - (b.b.x - b.a.x) * (b.b.y - a.a.y)) / delta;
        if (!allowOutOfRegion)
        {
            double mu = ((a.b.x - a.a.x) * (b.b.y - a.a.y) - (a.b.y - a.a.y) * (b.b.x - a.a.x)) / delta;
            if (mu &lt; 0 || 1 &lt; mu || ramda &lt; 0 || 1 &lt; ramda) return null;
        }
        return new Vector(a.a.x + ramda * (a.b.x - a.a.x), a.a.y + ramda * (a.b.y - a.a.y));
    }
    public override string ToString() =&gt; $$"{a} {b}";
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Vector2D</Title>
      <Shortcut>vector</Shortcut>
      <Description>二次元ベクトル</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>T</ID>
          <Default>double</Default>
          <ToolTip>型</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">struct Vector
{
    public $T$ x;
    public $T$ y;
    public $T$ this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { if (index == 0) return x; else return y; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { if (index == 0) x = value; else y = value; }
    }
    public $T$ Length =&gt; x * x + y * y;
    public double SqrtLength =&gt; Math.Sqrt(Length);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Vector($T$ x, $T$ y) { this.x = x; this.y = y; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Vector RotateVector(double radian) =&gt; new Vector(($T$)(x * Math.Cos(radian) - y * Math.Sin(radian)), ($T$)(x * Math.Sin(radian) + y * Math.Cos(radian)));
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static public $T$ CrossProduct(Vector a, Vector b) =&gt; a.x * b.y - a.y * b.x;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static public $T$ InnerProduct(Vector a, Vector b) =&gt; a.x * b.x + a.y * b.y;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector operator +(Vector a, Vector b) =&gt; new Vector(a.x + b.x, a.y + b.y);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Vector operator -(Vector a, Vector b) =&gt; new Vector(a.x - b.x, a.y - b.y);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator ==(Vector a, Vector b) =&gt; a.x == b.x &amp;&amp; a.y == b.y;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool operator !=(Vector a, Vector b) =&gt; a.x != b.x || a.y != b.y;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override bool Equals(object obj) =&gt; this == (Vector)obj;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override int GetHashCode() =&gt; x.GetHashCode() * 1000000007 + y.GetHashCode();
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override string ToString() =&gt; $$"({x},{y})";
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReRooting</Title>
      <Shortcut>rerooting</Shortcut>
      <Description>全方位木DP</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class ReRooting&lt;T&gt;
{
    public int NodeCount { get; private set; }

    int[][] Neighbours;
    int[][] IndexForNeighbours;

    T[] Res;
    T[][] dp;

    T IdentityElement;
    Func&lt;T, T, T&gt; Operate;
    Func&lt;T, T&gt; OperateNode;

    public ReRooting(int nodeCount, int[][] edges, T identityElement, Func&lt;T, T, T&gt; operate, Func&lt;T, T&gt; operateNode)
    {
        NodeCount = nodeCount;

        IdentityElement = identityElement;
        Operate = operate;
        OperateNode = operateNode;

        List&lt;int&gt;[] neighbours = new List&lt;int&gt;[nodeCount];
        List&lt;int&gt;[] indexForNeighbours = new List&lt;int&gt;[nodeCount];

        for (int i = 0; i &lt; nodeCount; i++)
        {
            neighbours[i] = new List&lt;int&gt;();
            indexForNeighbours[i] = new List&lt;int&gt;();
        }
        for (int i = 0; i &lt; edges.Length; i++)
        {
            var edge = edges[i];
            indexForNeighbours[edge[0]].Add(neighbours[edge[1]].Count);
            indexForNeighbours[edge[1]].Add(neighbours[edge[0]].Count);
            neighbours[edge[0]].Add(edge[1]);
            neighbours[edge[1]].Add(edge[0]);
        }

        Neighbours = new int[nodeCount][];
        IndexForNeighbours = new int[nodeCount][];
        for (int i = 0; i &lt; nodeCount; i++)
        {
            Neighbours[i] = neighbours[i].ToArray();
            IndexForNeighbours[i] = indexForNeighbours[i].ToArray();
        }

        dp = new T[Neighbours.Length][];
        Res = new T[Neighbours.Length];

        for (int i = 0; i &lt; Neighbours.Length; i++) dp[i] = new T[Neighbours[i].Length];
        if (NodeCount &gt; 1) Initialize();
        else Res[0] = OperateNode(IdentityElement);
    }

    public T Query(int node) =&gt; Res[node];

    private void Initialize()
    {
        int[] parents = new int[NodeCount];
        int[] order = new int[NodeCount];

        #region InitOrderedTree
        var index = 0;
        Stack&lt;int&gt; stack = new Stack&lt;int&gt;();
        stack.Push(0);
        parents[0] = -1;
        while (stack.Count &gt; 0)
        {
            var node = stack.Pop();
            order[index++] = node;
            for (int i = 0; i &lt; Neighbours[node].Length; i++)
            {
                var neighbour = Neighbours[node][i];
                if (neighbour == parents[node]) continue;
                stack.Push(neighbour);
                parents[neighbour] = node;
            }
        }
        #endregion

        #region fromLeaf
        for (int i = order.Length - 1; i &gt;= 1; i--)
        {
            var node = order[i];
            var parent = parents[node];

            T accum = IdentityElement;
            int neighbourIndex = -1;
            for (int j = 0; j &lt; Neighbours[node].Length; j++)
            {
                if (Neighbours[node][j] == parent)
                {
                    neighbourIndex = j;
                    continue;
                }
                accum = Operate(accum, dp[node][j]);
            }
            dp[parent][IndexForNeighbours[node][neighbourIndex]] = OperateNode(accum);
        }
        #endregion

        #region toLeaf
        for (int i = 0; i &lt; order.Length; i++)
        {
            var node = order[i];
            T accum = IdentityElement;
            T[] accumsFromTail = new T[Neighbours[node].Length];
            accumsFromTail[accumsFromTail.Length - 1] = IdentityElement;
            for (int j = accumsFromTail.Length - 1; j &gt;= 1; j--) accumsFromTail[j - 1] = Operate(dp[node][j], accumsFromTail[j]);
            for (int j = 0; j &lt; accumsFromTail.Length; j++)
            {
                dp[Neighbours[node][j]][IndexForNeighbours[node][j]] = OperateNode(Operate(accum, accumsFromTail[j]));
                accum = Operate(accum, dp[node][j]);
            }
            Res[node] = OperateNode(accum);
        }
        #endregion
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Binary-Indexed Tree</Title>
      <Shortcut>bit</Shortcut>
      <Description>Binary-Indexed Tree</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class BIT&lt;T&gt;
{
    public readonly int Size;
    T Identity;
    T[] Elements;
    Func&lt;T, T, T&gt; Merge;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public BIT(int size, T identity, Func&lt;T, T, T&gt; merge)
    {
        Size = size;
        Identity = identity;
        Merge = merge;
        Elements = new T[Size + 1];
        for (int i = 0; i &lt; Elements.Length; i++) Elements[i] = identity;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T Query(int r)
    {
        T res = Identity;
        for (r++; r &gt; 0; r -= r &amp; -r) res = Merge(res, Elements[r]);
        return res;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Operate(int i, T x)
    {
        for (i++; i &lt; Elements.Length; i += i &amp; -i) Elements[i] = Merge(Elements[i], x);
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Double-Ended Queue</Title>
      <Shortcut>deque</Shortcut>
      <Description>両端Queue</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class Deque&lt;T&gt; : IEnumerable&lt;T&gt;
{
    public int Count;
    T[] data; int FrontInd, BackInd;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Deque() { data = new T[1 &lt;&lt; 16]; FrontInd = 0; BackInd = data.Length - 1; Count = 0; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Deque(T[] elem)
    {
        int s = elem.Length; s |= s &gt;&gt; 1; s |= s &gt;&gt; 2; s |= s &gt;&gt; 4; s |= s &gt;&gt; 8; s |= s &gt;&gt; 16;
        data = new T[++s]; elem.CopyTo(data, 0);
        FrontInd = 0; BackInd = elem.Length - 1; Count = elem.Length;
    }

    public T Front
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { ValidateNoEmpty(); return data[FrontInd]; }
    }
    public T Back
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { ValidateNoEmpty(); return data[BackInd]; }
    }

    public T this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { if (index &gt;= Count) throw new Exception(); return data[FrontInd + index &amp; data.Length - 1]; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { if (index &gt;= Count) throw new Exception(); data[FrontInd + index &amp; data.Length - 1] = value; }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PushFront(T elem) { if (Count == data.Length) Extend(data.Length &lt;&lt; 1); Count++; data[FrontInd = (FrontInd - 1) &amp; data.Length - 1] = elem; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T PopFront() { var res = Front; FrontInd = (FrontInd + 1) &amp; data.Length - 1; Count--; return res; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PushBack(T elem) { if (Count == data.Length) Extend(data.Length &lt;&lt; 1); Count++; data[BackInd = (BackInd + 1) &amp; data.Length - 1] = elem; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T PopBack() { var res = Back; BackInd = (BackInd - 1) &amp; data.Length - 1; Count--; return res; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Extend(int newSize)
    {
        T[] newData = new T[newSize];
        if (0 &lt; Count)
        {
            if (FrontInd &lt;= BackInd) Array.Copy(data, FrontInd, newData, 0, Count);
            else
            {
                Array.Copy(data, FrontInd, newData, 0, data.Length - FrontInd);
                Array.Copy(data, 0, newData, data.Length - FrontInd, BackInd + 1);
            }
        }
        data = newData; FrontInd = 0; BackInd = Count - 1;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void ValidateNoEmpty() { if (Count == 0) throw new Exception(); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public IEnumerator&lt;T&gt; GetEnumerator() { for (int i = FrontInd; i != BackInd; i = i + 1 &amp; data.Length - 1) yield return data[i]; yield return data[BackInd]; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Disjoint Sparse Table</Title>
      <Shortcut>disjointsparsetable</Shortcut>
      <Description>Binary-Indexed Tree</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class DisjointSparseTable&lt;T&gt;
{
    public readonly int Size;
    readonly int Height;
    readonly T[] Table;
    readonly Func&lt;T, T, T&gt; Merge;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public DisjointSparseTable(T[] data, Func&lt;T, T, T&gt; merge)
    {
        Size = data.Length;
        Height = MSBPos(Size) + 1;
        Table = new T[Size * Height];
        Merge = merge;
        data.CopyTo(Table, 0);
        for (int layer = 1; layer &lt; Height; layer++)
        {
            int layerOffset = layer * Size;
            int block = 0;
            int i;
            for (; block + 2 &lt;= Size &gt;&gt; layer; block += 2)
            {
                i = layerOffset + ((block | 1) &lt;&lt; layer) - 1; Table[i] = Table[i - layerOffset]; i--;
                for (; i &gt;= layerOffset + (block &lt;&lt; layer); i--) Table[i] = Merge(Table[i - layerOffset], Table[i + 1]);
                i = layerOffset + ((block | 1) &lt;&lt; layer); Table[i] = Table[i - layerOffset]; i++;
                for (; i &lt; layerOffset + ((block + 2) &lt;&lt; layer); i++) Table[i] = Merge(Table[i - 1], Table[i - layerOffset]);
            }
            if (((block | 1) &lt;&lt; layer) &lt; Size)
            {
                i = layerOffset + ((block | 1) &lt;&lt; layer) - 1; Table[i] = Table[i - layerOffset]; i--;
                for (; i &gt;= layerOffset + (block &lt;&lt; layer); i--) Table[i] = Merge(Table[i - layerOffset], Table[i + 1]);
                i = layerOffset + ((block | 1) &lt;&lt; layer); Table[i] = Table[i - layerOffset]; i++;
                for (; i &lt; layerOffset + Size; i++) Table[i] = Merge(Table[i - 1], Table[i - layerOffset]);
            }
        }
    }

    public T Query(int l, int r)
    {
        if (l == r) return Table[l];
        var layer = MSBPos(l ^ r);
        return Merge(Table[l + layer * Size], Table[r + layer * Size]);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static int MSBPos(int n)
    {
        int res = 0;
        if (0 != (n &gt;&gt; (res | 16))) res |= 16;
        if (0 != (n &gt;&gt; (res | 8))) res |= 8;
        if (0 != (n &gt;&gt; (res | 4))) res |= 4;
        if (0 != (n &gt;&gt; (res | 2))) res |= 2;
        if (0 != (n &gt;&gt; (res | 1))) res |= 1;
        return res;
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Randomized Queue</Title>
      <Shortcut>rqueue</Shortcut>
      <Description>ランダムに要素をPopするQueue</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class RandomizedQueue&lt;T&gt;
{
    int front;
    T[] datas;
    Random RNG = new Random();
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public RandomizedQueue(int defaultSize = 512) { datas = new T[defaultSize]; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Push(T data)
    {
        if (front &gt;= datas.Length) Extend(datas.Length &lt;&lt; 1);
        datas[front++] = data;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T Pop()
    {
        ValidateNonEmpty();
        var index = RNG.Next() % front;
        var data = datas[index];
        datas[index] = datas[front--];
        return data;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Extend(int newSize)
    {
        T[] newDatas = new T[newSize];
        datas.CopyTo(newDatas, 0);
        datas = newDatas;
    }
    private void ValidateNonEmpty() { if (front == 0) throw new Exception(); }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>SuccientBitVector</Title>
      <Shortcut>sucbv</Shortcut>
      <Description>簡潔ビットベクトル</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class BitVector
{
    const int BITBLOCK_LENGTH = 32;
    const int BITBLOCK_LENGTH_BITS = 5;

    const int LARGEBLOCK_LENGTH = 256;
    const int LARGEBLOCK_LENGTH_BITS = 8;

    const int BLOCK_PER_LARGEBLOCK = 8;
    const int BLOCK_PER_LARGEBLOCK_BITS = 3;

    public readonly int Length;
    uint[] bits;
    byte[] count;
    int[] largeCount;
    int count0;
    int count1;

    public BitVector(uint[] bits) : this(bits, bits.Length * BITBLOCK_LENGTH) { }
    public BitVector(bool[] bits) : this(BoolsToUInts(bits), bits.Length) { }
    private BitVector(uint[] bits, int length)
    {
        Length = length;
        this.bits = bits;
        count = new byte[bits.Length];
        largeCount = new int[(bits.Length + BLOCK_PER_LARGEBLOCK - 1) &gt;&gt; BLOCK_PER_LARGEBLOCK_BITS];
        byte sum = 0;
        for (int i = 0; i &lt; bits.Length - 1; i++)
        {
            var popcnt = PopCount(bits[i]);
            if (((i + 1) &amp; (BLOCK_PER_LARGEBLOCK - 1)) == 0)
            {
                int ind = (i + 1) &gt;&gt; BLOCK_PER_LARGEBLOCK_BITS;
                largeCount[ind] = largeCount[ind - 1] + sum + popcnt;
                sum = 0;
            }
            else
            {
                sum += popcnt;
                count[i + 1] = sum;
            }
            count0 += BITBLOCK_LENGTH - popcnt;
            count1 += popcnt;
        }
        var lastpopcnt = PopCount(bits[bits.Length - 1]);
        count0 += BITBLOCK_LENGTH - lastpopcnt;
        count1 += lastpopcnt;
    }
    public bool this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return Access(index); }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool Access(int index) =&gt; (bits[index &gt;&gt; BITBLOCK_LENGTH_BITS] &amp; (1U &lt;&lt; index)) != 0;
    /// &lt;summary&gt;[0,index)のkindの個数&lt;/summary&gt;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Rank(int index, bool kind) =&gt; kind ? Rank(index) : index - Rank(index);

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Rank(int index)
    {
        int bitblockind = index &gt;&gt; BITBLOCK_LENGTH_BITS;
        return largeCount[bitblockind &gt;&gt; BLOCK_PER_LARGEBLOCK_BITS] + count[bitblockind] + PopCount(bits[bitblockind] &amp; ((1U &lt;&lt; index) - 1));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Select(int index, bool kind) =&gt; kind ? Select1(index) : Select0(index);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Select0(int index)
    {
        if (index &gt;= count0) return Length;
        int ok = 0;
        int ng = largeCount.Length;
        while (ng - ok &gt; 1)
        {
            int mid = (ng + ok) &gt;&gt; 1;
            if (((mid &lt;&lt; LARGEBLOCK_LENGTH_BITS) - largeCount[mid]) &lt;= index) ok = mid;
            else ng = mid;
        }
        int bitind;
        int remain = index - ((ok &lt;&lt; LARGEBLOCK_LENGTH_BITS) - largeCount[ok]);
        int offset = ok &lt;&lt; BLOCK_PER_LARGEBLOCK_BITS;
        for (bitind = Math.Min(BLOCK_PER_LARGEBLOCK, count.Length - offset) - 1; bitind &gt;= 1; bitind--) if (((bitind &lt;&lt; BITBLOCK_LENGTH_BITS) - count[offset + bitind]) &lt;= remain) break;
        return (ok &lt;&lt; LARGEBLOCK_LENGTH_BITS) + (bitind &lt;&lt; BITBLOCK_LENGTH_BITS) + Select(~bits[offset + bitind], (uint)(remain - (bitind * BITBLOCK_LENGTH - count[offset + bitind])));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Select1(int index)
    {
        if (index &gt;= count1) return Length;
        int ok = 0;
        int ng = largeCount.Length;
        while (ng - ok &gt; 1)
        {
            int mid = (ng + ok) &gt;&gt; 1;
            if (largeCount[mid] &lt;= index) ok = mid;
            else ng = mid;
        }
        int bitind;
        int remain = index - largeCount[ok];
        int offset = ok &lt;&lt; BLOCK_PER_LARGEBLOCK_BITS;
        for (bitind = Math.Min(BLOCK_PER_LARGEBLOCK, count.Length - offset) - 1; bitind &gt;= 1; bitind--) if (count[offset + bitind] &lt;= remain) break;
        return (ok &lt;&lt; LARGEBLOCK_LENGTH_BITS) + (bitind &lt;&lt; BITBLOCK_LENGTH_BITS) + Select(bits[offset + bitind], (uint)(remain - count[offset + bitind]));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static uint[] BoolsToUInts(bool[] bits)
    {
        var ulongbits = new uint[(bits.Length + BITBLOCK_LENGTH) &gt;&gt; BITBLOCK_LENGTH_BITS];
        for (int i = 0; i &lt; ulongbits.Length; i++)
        {
            int offset = i * BITBLOCK_LENGTH;
            int max = Math.Min(BITBLOCK_LENGTH, bits.Length - offset);
            for (int j = 0; j &lt; max; j++) if (bits[offset + j]) ulongbits[i] |= (1U &lt;&lt; j);
        }
        return ulongbits;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte Select(uint n, uint rank)
    {
        uint a = (n &amp; 0x55555555u) + ((n &gt;&gt; 1) &amp; 0x55555555u);
        uint b = (a &amp; 0x33333333u) + ((a &gt;&gt; 2) &amp; 0x33333333u);
        uint c = (b &amp; 0x0f0f0f0fu) + ((b &gt;&gt; 4) &amp; 0x0f0f0f0fu);
        uint t = (c &amp; 0xffu) + ((c &gt;&gt; 8) &amp; 0xffu);
        byte s = 0;
        if (rank &gt;= t) { s += 16; rank -= t; }
        t = (c &gt;&gt; s) &amp; 0xf;
        if (rank &gt;= t) { s += 8; rank -= t; }
        t = (b &gt;&gt; s) &amp; 0x7;
        if (rank &gt;= t) { s += 4; rank -= t; }
        t = (a &gt;&gt; s) &amp; 0x3;
        if (rank &gt;= t) { s += 2; rank -= t; }
        t = (n &gt;&gt; s) &amp; 0x1;
        if (rank &gt;= t) s++;
        return s;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static byte PopCount(uint n)
    {
        n -= ((n &gt;&gt; 1) &amp; 0x55555555U);
        n = (n &amp; 0x33333333U) + ((n &gt;&gt; 2) &amp; 0x33333333U);
        return (byte)(((n + (n &gt;&gt; 4) &amp; 0xF0F0F0FU) * 0x1010101U) &gt;&gt; 24);
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Immutable Array</Title>
      <Shortcut>iarray</Shortcut>
      <Description>永続配列</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class ImmutableArray&lt;T&gt; : IEnumerable&lt;T&gt;
{
    public int Length { get; private set; }
    Node Root;

    private ImmutableArray() { }
    public ImmutableArray(int length)
    {
        Length = length;

        int RootIndex = 1;
        while (RootIndex &lt;= length) RootIndex &lt;&lt;= 1;
        RootIndex &gt;&gt;= 1;

        Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
        stack.Push(Root = new Node() { Index = RootIndex - 1 });
        while (stack.Count &gt; 0)
        {
            var item = stack.Pop();
            var parentIndex = item.Index;
            var lsb = -(parentIndex + 1) &amp; (parentIndex + 1);
            if (lsb == 1) continue;
            lsb &gt;&gt;= 1;
            stack.Push(item.Left = new Node() { Index = parentIndex - lsb });

            while (parentIndex + lsb &gt;= Length) lsb &gt;&gt;= 1;
            stack.Push(item.Right = new Node() { Index = parentIndex + lsb });
        }
    }

    public T this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return GetValue(index); }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ImmutableArray&lt;T&gt; SetValue(int index, T value)
    {
        Node node = Root.GetCopy();
        var newList = new ImmutableArray&lt;T&gt;() { Root = node, Length = Length };
        while (index != node.Index)
        {
            if (index &lt; node.Index) node = (node.Left = node.Left.GetCopy());
            else node = (node.Right = node.Right.GetCopy());
        }
        node.Value = value;
        return newList;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T GetValue(int index)
    {
        Node node = Root;
        while (index != node.Index)
        {
            if (index &lt; node.Index) node = node.Left;
            else node = node.Right;
        }
        return node.Value;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public IEnumerator&lt;T&gt; GetEnumerator()
    {
        Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
        Node item = Root;
        stack.Push(item);
        while (item.Left != null) stack.Push(item = item.Left);
        while (stack.Count &gt; 0)
        {
            yield return (item = stack.Pop()).Value;
            if (item.Right != null)
            {
                stack.Push(item = item.Right);
                while (item.Left != null) stack.Push(item = item.Left);
            }
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T[] ToArray()
    {
        T[] res = new T[Length];
        Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();
        stack.Push(Root);
        while (stack.Count &gt; 0)
        {
            var item = stack.Pop();
            if (item.Left != null)
            {
                stack.Push(item.Left);
                if (item.Right != null) stack.Push(item.Right);
            }
            res[item.Index] = item.Value;
        }
        return res;
    }

    IEnumerator IEnumerable.GetEnumerator() { return GetEnumerator(); }

    class Node
    {
        public int Index;
        public T Value;
        public Node Left;
        public Node Right;
        public Node GetCopy() =&gt; new Node() { Index = Index, Value = Value, Left = Left, Right = Right };
        public override string ToString() =&gt; Value.ToString();
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Immutable Stack</Title>
      <Shortcut>istack</Shortcut>
      <Description>永続Stack</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class ImmutableStack&lt;T&gt;
{
    readonly ImmutableStack&lt;T&gt; previousStack;
    public readonly T Top;
    public readonly int Count;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ImmutableStack() : this(null, default, 0) { }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private ImmutableStack(ImmutableStack&lt;T&gt; prev, T top, int count)
    {
        previousStack = prev;
        Top = top;
        Count = count;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ImmutableStack&lt;T&gt; Push(T value) =&gt; new ImmutableStack&lt;T&gt;(this, value, Count + 1);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ImmutableStack&lt;T&gt; Pop() =&gt; previousStack == null ? null : previousStack;
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Divisors</Title>
      <Shortcut>divisors</Shortcut>
      <Description>約数列挙</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
        <Import>
          <Namespace>static System.Math</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">static IEnumerable&lt;long&gt; Divisors(long n)
{
    var max = (int)Ceiling(Sqrt(n));
    for (int i = 1; i &lt;= max; i++)
        if (n % i == 0) { yield return i; yield return n / i; }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Extended Euclidean algorithm</Title>
      <Shortcut>extgcd</Shortcut>
      <Description>gcd=ax+byなるx,yを見つける</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Code Language="CSharp">static long ExtGCD(long a, long b, out long x, out long y)
{
    long div;
    long x1 = 1, y1 = 0, x2 = 0, y2 = 1;
    while (true)
    {
        if (b == 0) { x = x1; y = y1; return a; }
        div = a / b; x1 -= x2 * div; y1 -= y2 * div; a %= b;
        if (a == 0) { x = x2; y = y2; return b; }
        div = b / a; x2 -= x1 * div; y2 -= y1 * div; b %= a;
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Greatest Common Divisor</Title>
      <Shortcut>gcd</Shortcut>
      <Description>最大公約数を見つける</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Code Language="CSharp">static long GCD(long a, long b)
{
    while (true)
    {
        if (b == 0) return a;
        a %= b;
        if (a == 0) return b;
        b %= a;
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Least Common Multiple</Title>
      <Shortcut>lcm</Shortcut>
      <Description>最小公倍数を見つける</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Code Language="CSharp">static long LCM(long a, long b) { return a / GCD(a, b) * b; }</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ModInt</Title>
      <Shortcut>modint</Shortcut>
      <Description>剰余環</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">struct ModInt
{
    const int MOD = 1000000007;
    const long POSITIVIZER = ((long)MOD) &lt;&lt; 31;
    long Data;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ModInt(long data) { if ((Data = data % MOD) &lt; 0) Data += MOD; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator long(ModInt modInt) =&gt; modInt.Data;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static implicit operator ModInt(long val) =&gt; new ModInt(val);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ModInt operator +(ModInt a, int b) =&gt; new ModInt() { Data = (a.Data + b + POSITIVIZER) % MOD };
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ModInt operator +(ModInt a, long b) =&gt; new ModInt(a.Data + b);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ModInt operator +(ModInt a, ModInt b) { long res = a.Data + b.Data; return new ModInt() { Data = res &gt;= MOD ? res - MOD : res }; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ModInt operator -(ModInt a, int b) =&gt; new ModInt() { Data = (a.Data - b + POSITIVIZER) % MOD };
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ModInt operator -(ModInt a, long b) =&gt; new ModInt(a.Data - b);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ModInt operator -(ModInt a, ModInt b) { long res = a.Data - b.Data; return new ModInt() { Data = res &lt; 0 ? res + MOD : res }; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ModInt operator *(ModInt a, int b) =&gt; new ModInt(a.Data * b);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ModInt operator *(ModInt a, long b) =&gt; a * new ModInt(b);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ModInt operator *(ModInt a, ModInt b) =&gt; new ModInt() { Data = a.Data * b.Data % MOD };
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ModInt operator /(ModInt a, ModInt b) =&gt; new ModInt() { Data = a.Data * GetInverse(b) % MOD };
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public override string ToString() =&gt; Data.ToString();
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static long GetInverse(long a)
    {
        long div, p = MOD, x1 = 1, y1 = 0, x2 = 0, y2 = 1;
        while (true)
        {
            if (p == 1) return x2 + MOD; div = a / p; x1 -= x2 * div; y1 -= y2 * div; a %= p;
            if (a == 1) return x1 + MOD; div = p / a; x2 -= x1 * div; y2 -= y1 * div; p %= a;
        }
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Power</Title>
      <Shortcut>pow</Shortcut>
      <Description>モノイドの冪演算</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Declarations>
        <Literal>
          <ID>T</ID>
          <Default>ModInt</Default>
          <ToolTip>型</ToolTip>
        </Literal>
        <Literal>
          <ID>IdentityElement</ID>
          <Default>1</Default>
          <ToolTip>単位元</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">static $T$ Power($T$ n, long m)
{
    $T$ pow = n;
    $T$ res = $IdentityElement$;
    while (m &gt; 0)
    {
        if ((m &amp; 1) == 1) res *= pow;
        pow *= pow;
        m &gt;&gt;= 1;
    }
    return res;
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Prime Factorization</Title>
      <Shortcut>primefactori</Shortcut>
      <Description>素因数分解</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">static IEnumerable&lt;long&gt; PrimeFactors(long n)
{
    while ((n &amp; 1) == 0)
    {
        n &gt;&gt;= 1;
        yield return 2;
    }
    for (long i = 3; i * i &lt;= n; i += 2)
    {
        while (n % i == 0)
        {
            n /= i;
            yield return i;
        }
    }
    if (n != 1) yield return n;
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>AbortFunc</Title>
      <Shortcut>abortfun</Shortcut>
      <Description>messageを出力してプログラムを終了する</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>message</ID>
          <Default>"No"</Default>
          <ToolTip>出力するメッセージ</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">Action abort = () =&gt; { Console.WriteLine($message$); Environment.Exit(0); };</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Grid Graph Edges Generator</Title>
      <Shortcut>gridedges</Shortcut>
      <Description>グリッドグラフの辺を生成する</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>graph</ID>
          <Default>graph</Default>
          <ToolTip>変数</ToolTip>
        </Literal>
        <Literal>
          <ID>h</ID>
          <Default>h</Default>
          <ToolTip>高さ</ToolTip>
        </Literal>
        <Literal>
          <ID>w</ID>
          <Default>w</Default>
          <ToolTip>横幅</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">List&lt;int&gt;[] $graph$ = Enumerable.Repeat(0, $h$ * $w$).Select(_ =&gt; new List&lt;int&gt;()).ToArray();
for (int i = 0; i &lt; $h$ - 1; i++)
    for (int j = 0; j &lt; $w$; j++)
    { var id = i * $w$ + j; graph[id].Add(id + $w$); graph[id + $w$].Add(id); }
for (int i = 0; i &lt; $h$; i++)
    for (int j = 0; j &lt; $w$ - 1; j++)
    { var id = i * $w$ + j; graph[id].Add(id + 1); graph[id + 1].Add(id); }</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Random Number Generator</Title>
      <Shortcut>rng</Shortcut>
      <Description>Xorshiftを用いた乱数生成器</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Runtime.InteropServices</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">[StructLayout(LayoutKind.Explicit)]
class Random
{
    [FieldOffset(0)]
    private byte __byte;
    [FieldOffset(0)]
    private sbyte __sbyte;
    [FieldOffset(0)]
    private char __char;
    [FieldOffset(0)]
    private short __short;
    [FieldOffset(0)]
    private ushort __ushort;
    [FieldOffset(0)]
    private int __int;
    [FieldOffset(0)]
    private uint __uint;
    [FieldOffset(0)]
    private long __long;
    [FieldOffset(0)]
    private ulong __ulong;

    public byte Byte { get { Update(); return __byte; } }
    public sbyte SByte { get { Update(); return __sbyte; } }
    public char Char { get { Update(); return __char; } }
    public short Short { get { Update(); return __short; } }
    public ushort UShort { get { Update(); return __ushort; } }
    public int Int { get { Update(); return __int; } }
    public uint UInt { get { Update(); return __uint; } }
    public long Long { get { Update(); return __long; } }
    public ulong ULong { get { Update(); return __ulong; } }
    public double Double { get { return (double)ULong / ulong.MaxValue; } }

    [FieldOffset(0)]
    private ulong _xorshift;

    public Random() : this((ulong)DateTime.Now.Ticks) { }
    public Random(ulong seed) { SetSeed(seed); }
    public void SetSeed(ulong seed) =&gt; _xorshift = seed * 0x3141592c0ffeeul;

    public int Next() =&gt; Int &amp; 2147483647;
    public void Update()
    {
        _xorshift ^= _xorshift &lt;&lt; 7;
        _xorshift ^= _xorshift &gt;&gt; 9;
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Template for AtCoder</Title>
      <Shortcut>tmplatcoder</Shortcut>
      <Description>AtCoder用のテンプレート</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.IO</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
        <Import>
          <Namespace>System.Text</Namespace>
        </Import>
        <Import>
          <Namespace>System.Numerics</Namespace>
        </Import>
        <Import>
          <Namespace>System.Diagnostics</Namespace>
        </Import>
        <Import>
          <Namespace>System.Threading.Tasks</Namespace>
        </Import>
        <Import>
          <Namespace>System.Text.RegularExpressions</Namespace>
        </Import>
        <Import>
          <Namespace>static System.Math</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">public static class P
{
    public static void Main()
    {
        $end$
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Template for Google Code Jam</Title>
      <Shortcut>tmplgcj</Shortcut>
      <Description>gcjのアレ</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.IO</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
        <Import>
          <Namespace>System.Text</Namespace>
        </Import>
        <Import>
          <Namespace>System.Diagnostics</Namespace>
        </Import>
        <Import>
          <Namespace>System.Threading.Tasks</Namespace>
        </Import>
        <Import>
          <Namespace>System.Text.RegularExpressions</Namespace>
        </Import>
        <Import>
          <Namespace>static System.Math</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">public static class P
{
    public static void Main()
    {
        int k = int.Parse(Console.ReadLine());
        StringBuilder builder = new StringBuilder();
        for (int i = 1; i &lt;= k; i++) builder.AppendLine($$"Case #{i}: {Solve()}");
        Console.WriteLine(builder.ToString());
    }

    static string Solve()
    {
        $end$
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Template for Library</Title>
      <Shortcut>tmpllib</Shortcut>
      <Description>ライブラリ用のテンプレート</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Declarations>
        <Literal>
          <ID>title</ID>
          <Default>title</Default>
          <ToolTip>スニペット名</ToolTip>
        </Literal>
        <Literal>
          <ID>shortcut</ID>
          <Default>shortcut</Default>
          <ToolTip>ショートカット</ToolTip>
        </Literal>
        <Literal>
          <ID>description</ID>
          <Default>description</Default>
          <ToolTip>説明</ToolTip>
        </Literal>
        <Literal>
          <ID>author</ID>
          <Default>keymoon</Default>
          <ToolTip>作者</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">///Title : $title$
///Shortcut : $shortcut$
///Description : $description$
///Author : $author$

using System;

#if !DECLARATIONS

#endif</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Permutations(duplicated elements)</Title>
      <Shortcut>permsd</Shortcut>
      <Description>重複あり配列要素の並び替えを生成</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">static IEnumerable&lt;T[]&gt; Permutations&lt;T&gt;(T[] array) where T : IComparable&lt;T&gt;
{
    int index = 0;
    yield return array;
    while (true)
    {
        for (int i = array.Length - 1; i &gt; 0; i--)
        {
            if (array[i - 1].CompareTo(array[i]) &gt;= 0) continue;
            int j = Array.FindLastIndex(array, x =&gt; array[i - 1].CompareTo(x) &lt; 0);
            T tmp = array[i - 1]; array[i - 1] = array[j]; array[j] = tmp;
            Array.Reverse(array, i, array.Length - i);
            yield return array;
            goto end;
        }
        Array.Reverse(array, index, array.Length);
        yield break;
    end:;
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Permutations(non-duplicated elements)</Title>
      <Shortcut>permsnd</Shortcut>
      <Description>重複なし配列要素の並び替えを生成(Johnson–Trotter algorithm)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">static IEnumerable&lt;T[]&gt; Permutations&lt;T&gt;(T[] array)
{
    long total = 1;
    for (int i = 2; i &lt; array.Length; i++) total *= i;
    for (total &gt;&gt;= 1; total &gt;= 1; total -= 1)
    {
        for (int j = 0; j &lt; array.Length - 1; j++)  { yield return array;  Swap(ref array[j], ref array[j + 1]); }
        yield return array; Swap(ref array[0], ref array[1]);
        for (int j = array.Length - 2; j &gt;= 0; j--)  { yield return array; Swap(ref array[j], ref array[j + 1]); }
        yield return array; Swap(ref array[array.Length - 1], ref array[array.Length - 2]);
    }
}
static void Swap&lt;T&gt;(ref T a, ref T b) { T tmp = a; a = b; b = tmp; }</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Rolling Hash</Title>
      <Shortcut>rollinghash</Shortcut>
      <Description>固定modローリングハッシュ</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>MAX_LENGTH</ID>
          <Default>500000</Default>
          <ToolTip />
        </Literal>
      </Declarations>
      <Code Language="CSharp">class RollingHash
{
    const ulong MASK30 = (1UL &lt;&lt; 30) - 1;
    const ulong MASK31 = (1UL &lt;&lt; 31) - 1;
    const ulong MOD = (1UL &lt;&lt; 61) - 1;
    const ulong POSITIVIZER = MOD * ((1UL &lt;&lt; 3) - 1);
    static uint Base;
    static ulong[] powMemo = new ulong[$MAX_LENGTH$ + 1];
    static RollingHash()
    {
        Base = (uint)new Random().Next(129, int.MaxValue);
        powMemo[0] = 1;
        for (int i = 1; i &lt; powMemo.Length; i++)
            powMemo[i] = CalcMod(Mul(powMemo[i - 1], Base));
    }

    ulong[] hash;

    public RollingHash(string s)
    {
        hash = new ulong[s.Length + 1];
        for (int i = 0; i &lt; s.Length; i++)
            hash[i + 1] = CalcMod(Mul(hash[i], Base) + s[i]);
    }

    public ulong Slice(int begin, int length)
    {
        return CalcMod(hash[begin + length] + POSITIVIZER - Mul(hash[begin], powMemo[length]));
    }

    private static ulong Mul(ulong l, ulong r)
    {
        var lu = l &gt;&gt; 31;
        var ld = l &amp; MASK31;
        var ru = r &gt;&gt; 31;
        var rd = r &amp; MASK31;
        var middleBit = ld * ru + lu * rd;
        return ((lu * ru) &lt;&lt; 1) + ld * rd + ((middleBit &amp; MASK30) &lt;&lt; 31) + (middleBit &gt;&gt; 30);
    }

    private static ulong Mul(ulong l, uint r)
    {
        var lu = l &gt;&gt; 31;
        var rd = r &amp; MASK31;
        var middleBit = lu * rd;
        return  (l &amp; MASK31) * rd + ((middleBit &amp; MASK30) &lt;&lt; 31) + (middleBit &gt;&gt; 30);
    }

    private static ulong CalcMod(ulong val)
    {
        val = (val &amp; MOD) + (val &gt;&gt; 61);
        if (val &gt; MOD) val -= MOD;
        return val;
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Most Significant Bit(int)</Title>
      <Shortcut>msbi</Shortcut>
      <Description>最も上に立っているbit(0-indexed)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>T</ID>
          <Default>int</Default>
          <ToolTip>型</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">[MethodImpl(MethodImplOptions.AggressiveInlining)]
static $T$ MSB($T$ s) { s |= s &gt;&gt; 1; s |= s &gt;&gt; 2; s |= s &gt;&gt; 4; s |= s &gt;&gt; 8; s |= s &gt;&gt; 16; return (s + 1) &gt;&gt; 1; }</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Most Significant Bit(long)</Title>
      <Shortcut>msbl</Shortcut>
      <Description>最も上に立っているbit(0-indexed)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>T</ID>
          <Default>long</Default>
          <ToolTip>型</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">[MethodImpl(MethodImplOptions.AggressiveInlining)]
static $T$ MSB($T$ s) { s |= s &gt;&gt; 1; s |= s &gt;&gt; 2; s |= s &gt;&gt; 4; s |= s &gt;&gt; 8; s |= s &gt;&gt; 16; s |= s &gt;&gt; 32; return (s + 1) &gt;&gt; 1; }</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Most Significant Bit Position(int)</Title>
      <Shortcut>msbposi</Shortcut>
      <Description>最も上に立っているbitのindex(0-indexed)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>T</ID>
          <Default>int</Default>
          <ToolTip>型</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">[MethodImpl(MethodImplOptions.AggressiveInlining)]
static int MSBPos($T$ n)
{
    int res = 0;
    if (0 != (n &gt;&gt; (res | 16))) res |= 16;
    if (0 != (n &gt;&gt; (res | 8))) res |= 8;
    if (0 != (n &gt;&gt; (res | 4))) res |= 4;
    if (0 != (n &gt;&gt; (res | 2))) res |= 2;
    if (0 != (n &gt;&gt; (res | 1))) res |= 1;
    return res;
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Most Significant Bit Position(long)</Title>
      <Shortcut>msbposl</Shortcut>
      <Description>最も上に立っているbitのindex(0-indexed)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>T</ID>
          <Default>long</Default>
          <ToolTip>型</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">[MethodImpl(MethodImplOptions.AggressiveInlining)]
static int MSBPos($T$ n)
{
    int res = 0;
    if (0 != (n &gt;&gt; (res | 32))) res |= 32;
    if (0 != (n &gt;&gt; (res | 16))) res |= 16;
    if (0 != (n &gt;&gt; (res | 8))) res |= 8;
    if (0 != (n &gt;&gt; (res | 4))) res |= 4;
    if (0 != (n &gt;&gt; (res | 2))) res |= 2;
    if (0 != (n &gt;&gt; (res | 1))) res |= 1;
    return res;
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>PopCount(signed)</Title>
      <Shortcut>popcounts</Shortcut>
      <Description>符号つき整数のビットの立っている数</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>T</ID>
          <Default>int</Default>
          <ToolTip>型</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">[MethodImpl(MethodImplOptions.AggressiveInlining)]
static int PopCount($T$ n)
{
    int msb = 0;
    if (n &lt; 0) { n &amp;= int.MaxValue; msb = 1; }
    n = n - ((n &gt;&gt; 1) &amp; 0x55555555);
    n = (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333);
    return (int)(((n + (n &gt;&gt; 4) &amp; 0xF0F0F0F) * 0x1010101) &gt;&gt; 24) + msb;
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>PopCount(unsigned)</Title>
      <Shortcut>popcountu</Shortcut>
      <Description>符号なし整数のビットの立っている数</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>T</ID>
          <Default>uint</Default>
          <ToolTip>型</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">[MethodImpl(MethodImplOptions.AggressiveInlining)]
static int PopCount($T$ n)
{
    n = n - ((n &gt;&gt; 1) &amp; 0x55555555);
    n = (n &amp; 0x33333333) + ((n &gt;&gt; 2) &amp; 0x33333333);
    return (int)(((n + (n &gt;&gt; 4) &amp; 0xF0F0F0F) * 0x1010101) &gt;&gt; 24);
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>FoldableDeque</Title>
      <Shortcut>fdeque</Shortcut>
      <Description>Sliding-Window Aggregationが可能なQueue</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class FoldableDeque&lt;T&gt;
{
    public int Count { get; private set; }
    T[] data; int FrontInd, BackInd;
    Stack&lt;T&gt; FrontValues = new Stack&lt;T&gt;();
    Stack&lt;T&gt; BackValues = new Stack&lt;T&gt;();
    Func&lt;T, T, T&gt; Merge;

    public T Value
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            return
                FrontValues.Count == 0 ? BackValues.Peek() :
                BackValues.Count == 0 ? FrontValues.Peek() :
                Merge(FrontValues.Peek(), BackValues.Peek());
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public FoldableDeque(Func&lt;T, T, T&gt; merge)
    {
        data = new T[1 &lt;&lt; 16];
        FrontInd = 0;
        BackInd = data.Length - 1;
        Count = 0;
        Merge = merge;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PushFront(T item)
    {
        if (Count == data.Length) Extend(data.Length &lt;&lt; 1);
        data[FrontInd = (FrontInd - 1) &amp; data.Length - 1] = item; Count++;
        FrontValues.Push(FrontValues.Count == 0 ? item : Merge(item, FrontValues.Peek()));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PushBack(T item)
    {
        if (Count == data.Length) Extend(data.Length &lt;&lt; 1);
        data[BackInd = (BackInd + 1) &amp; data.Length - 1] = item; Count++;
        BackValues.Push(BackValues.Count == 0 ? item : Merge(BackValues.Peek(), item));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PopFront()
    {
        Validate();
        FrontInd = (FrontInd + 1) &amp; data.Length - 1; Count--;
        if (FrontValues.Count == 0) Reconstruct();
        else FrontValues.Pop();
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void PopBack()
    {
        Validate();
        BackInd = (BackInd - 1) &amp; data.Length - 1; Count--;
        if (BackValues.Count == 0) Reconstruct();
        else BackValues.Pop();
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Reconstruct()
    {
        int ind;
        FrontValues.Clear();
        BackValues.Clear();
        if (Count == 0) return;
        ind = (FrontInd + (Count &gt;&gt; 1)) &amp; data.Length - 1;
        BackValues.Push(data[ind]);
        if (ind &lt;= BackInd)
        {
            for (ind++; ind &lt;= BackInd; ind++)
                BackValues.Push(Merge(BackValues.Peek(), data[ind]));
        }
        else
        {
            for (ind++; ind &lt; data.Length; ind++)
                BackValues.Push(Merge(BackValues.Peek(), data[ind]));
            for (ind = 0; ind &lt;= BackInd; ind++)
                BackValues.Push(Merge(BackValues.Peek(), data[ind]));
        }
        if (Count == 1) return;
        ind = (FrontInd + (Count &gt;&gt; 1) - 1) &amp; data.Length - 1;
        FrontValues.Push(data[ind]);
        if (FrontInd &lt;= ind)
        {
            for (ind--; FrontInd &lt;= ind; ind--)
                FrontValues.Push(Merge(data[ind], FrontValues.Peek()));
        }
        else
        {
            for (ind--; 0 &lt;= ind; ind--)
                FrontValues.Push(Merge(data[ind], FrontValues.Peek()));
            for (ind = data.Length - 1; FrontInd &lt;= ind; ind--)
                FrontValues.Push(Merge(data[ind], FrontValues.Peek()));
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Extend(int newSize)
    {
        T[] newData = new T[newSize];
        if (0 &lt; Count)
        {
            if (FrontInd &lt;= BackInd) Array.Copy(data, FrontInd, newData, 0, Count);
            else
            {
                Array.Copy(data, FrontInd, newData, 0, data.Length - FrontInd);
                Array.Copy(data, 0, newData, data.Length - FrontInd, BackInd + 1);
            }
        }
        data = newData; FrontInd = 0; BackInd = Count - 1;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Validate() { if (Count == 0) throw new Exception(); }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>FoldableQueue</Title>
      <Shortcut>fqueue</Shortcut>
      <Description>要素のfoldが可能なQueue</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class FoldableQueue&lt;T&gt;
{
    public int Count { get; private set; }
    public T Value
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            return
                TailValueStack.Count == 0 ? FrontValue :
                FrontIsEmpty ? TailValueStack.Peek() :
                Merge(TailValueStack.Peek(), FrontValue);
        }
    }

    bool FrontIsEmpty = true;
    T FrontValue;
    Stack&lt;T&gt; Fronts = new Stack&lt;T&gt;();
    Stack&lt;T&gt; TailValueStack = new Stack&lt;T&gt;();

    Func&lt;T, T, T&gt; Merge;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public FoldableQueue(Func&lt;T, T, T&gt; merge) { Merge = merge; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Pop()
    {
        Validate();
        if (TailValueStack.Count == 0) Move();
        TailValueStack.Pop();
        Count--;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Push(T item)
    {
        Fronts.Push(item);
        Count++;
        FrontValue = FrontIsEmpty ? item : Merge(FrontValue, item);
        FrontIsEmpty = false;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Move()
    {
        TailValueStack.Push(Fronts.Pop());
        while (0 &lt; Fronts.Count)
            TailValueStack.Push(Merge(Fronts.Pop(), TailValueStack.Peek()));
        FrontIsEmpty = true;
    }

    private void Validate() { if (Count == 0) throw new Exception(); }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>PriorityQueue with Key</Title>
      <Shortcut>pqueuek</Shortcut>
      <Description>キーによる優先度付きキュー</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class PriorityQueue&lt;TValue, TKey&gt; where TKey : IComparable&lt;TKey&gt;
{
    public int Count { get; private set; }
    private Func&lt;TValue, TKey&gt; KeySelector;
    private bool Descendance;
    private TValue[] data = new TValue[65536];
    private TKey[] keys = new TKey[65536];
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PriorityQueue(Func&lt;TValue, TKey&gt; keySelector, bool descendance = false) { KeySelector = keySelector; Descendance = descendance; }
    public TValue Top
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { ValidateNonEmpty(); return data[1]; }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public TValue Pop()
    {
        var top = Top;
        var item = data[Count];
        var key = keys[Count--];
        int index = 1;
        while (true)
        {
            if ((index &lt;&lt; 1) &gt;= Count)
            {
                if (index &lt;&lt; 1 &gt; Count) break;
                if (key.CompareTo(keys[index &lt;&lt; 1]) &gt; 0 ^ Descendance)
                { data[index] = data[index &lt;&lt; 1]; keys[index] = keys[index &lt;&lt; 1]; index &lt;&lt;= 1; }
                else break;
            }
            else
            {
                var nextIndex = keys[index &lt;&lt; 1].CompareTo(keys[(index &lt;&lt; 1) + 1]) &lt;= 0 ^ Descendance ? (index &lt;&lt; 1) : (index &lt;&lt; 1) + 1;
                if (key.CompareTo(keys[nextIndex]) &gt; 0 ^ Descendance)
                { data[index] = data[nextIndex]; keys[index] = keys[nextIndex]; index = nextIndex; }
                else break;
            }
        }
        data[index] = item;
        keys[index] = key;
        return top;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Push(TValue item)
    {
        var key = KeySelector(item);
        int index = ++Count;
        if (data.Length == Count) Extend(data.Length * 2);
        while ((index &gt;&gt; 1) != 0)
        {
            if (keys[index &gt;&gt; 1].CompareTo(key) &gt; 0 ^ Descendance)
            { data[index] = data[index &gt;&gt; 1]; keys[index] = keys[index &gt;&gt; 1]; index &gt;&gt;= 1; }
            else break;
        }
        data[index] = item;
        keys[index] = key;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Extend(int newSize)
    {
        TValue[] newData = new TValue[newSize];
        TKey[] newKeys = new TKey[newSize];
        data.CopyTo(newData, 0);
        keys.CopyTo(newKeys, 0);
        data = newData;
        keys = newKeys;
    }
    private void ValidateNonEmpty() { if (Count == 0) throw new IndexOutOfRangeException(); }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>PriorityQueue</Title>
      <Shortcut>pqueue</Shortcut>
      <Description>優先度付きキュー</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class PriorityQueue&lt;T&gt; where T : IComparable&lt;T&gt;
{
    public int Count { get; private set; }
    private bool Descendance;
    private T[] data = new T[65536];
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public PriorityQueue(bool descendance = false) { Descendance = descendance; }
    public T Top
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { ValidateNonEmpty(); return data[1]; }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T Pop()
    {
        var top = Top;
        var elem = data[Count--];
        int index = 1;
        while (true)
        {
            if ((index &lt;&lt; 1) &gt;= Count)
            {
                if (index &lt;&lt; 1 &gt; Count) break;
                if (elem.CompareTo(data[index &lt;&lt; 1]) &gt; 0 ^ Descendance) data[index] = data[index &lt;&lt;= 1];
                else break;
            }
            else
            {
                var nextIndex = data[index &lt;&lt; 1].CompareTo(data[(index &lt;&lt; 1) + 1]) &lt;= 0 ^ Descendance ? (index &lt;&lt; 1) : (index &lt;&lt; 1) + 1;
                if (elem.CompareTo(data[nextIndex]) &gt; 0 ^ Descendance) data[index] = data[index = nextIndex];
                else break;
            }
        }
        data[index] = elem;
        return top;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Push(T value)
    {
        int index = ++Count;
        if (data.Length == Count) Extend(data.Length * 2);
        while ((index &gt;&gt; 1) != 0)
        {
            if (data[index &gt;&gt; 1].CompareTo(value) &gt; 0 ^ Descendance) data[index] = data[index &gt;&gt;= 1];
            else break;
        }
        data[index] = value;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Extend(int newSize)
    {
        T[] newDatas = new T[newSize];
        data.CopyTo(newDatas, 0);
        data = newDatas;
    }
    private void ValidateNonEmpty() { if (Count == 0) throw new Exception(); }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>SegmentTree(Point Update/Range Query)</Title>
      <Shortcut>segtreepr</Shortcut>
      <Description>一点更新区間取得</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class SegmentTree&lt;T&gt;
{
    public int Size { get; private set; }
    T Identity;
    T[] Data;
    Func&lt;T, T, T&gt; Merge;
    int LeafCount;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SegmentTree(int size, T identity, Func&lt;T, T, T&gt; merge)
    {
        Init(size, identity, merge);
        for (int i = 1; i &lt; Data.Length; i++) Data[i] = identity;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SegmentTree(T[] elems, T identity, Func&lt;T, T, T&gt; merge)
    {
        Init(elems.Length, identity, merge);
        elems.CopyTo(Data, LeafCount);
        for (int i = elems.Length + LeafCount; i &lt; Data.Length; i++) Data[i] = identity;
        for (int i = LeafCount - 1; i &gt;= 1; i--) Data[i] = Merge(Data[i &lt;&lt; 1], Data[(i &lt;&lt; 1) | 1]);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Init(int size, T identity, Func&lt;T, T, T&gt; merge)
    {
        Size = size;
        Identity = identity;
        Merge = merge;
        LeafCount = 1;
        while (LeafCount &lt; size) LeafCount &lt;&lt;= 1;
        Data = new T[LeafCount &lt;&lt; 1];
    }

    public T this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return Data[LeafCount + index]; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { Update(index, value); }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Update(int i, T x) { Data[i += LeafCount] = x; while (0 &lt; (i &gt;&gt;= 1)) Data[i] = Merge(Data[i &lt;&lt; 1], Data[(i &lt;&lt; 1) | 1]); }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Operate(int i, T x) { Data[i += LeafCount] = Merge(Data[i], x); while (0 &lt; (i &gt;&gt;= 1)) Data[i] = Merge(Data[i &lt;&lt; 1], Data[(i &lt;&lt; 1) | 1]); }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T Query(int l, int r)
    {
        T lRes = Identity, rRes = Identity;
        for (l += LeafCount, r += LeafCount; l &lt;= r; l = (l + 1) &gt;&gt; 1, r = (r - 1) &gt;&gt; 1 )
        {
            if ((l &amp; 1) == 1) lRes = Merge(lRes, Data[l]); if ((r &amp; 1) == 0) rRes = Merge(Data[r], rRes);
        }
        return Merge(lRes, rRes);
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>SegmentTree(Range Update/Point Query, Commutative operation)</Title>
      <Shortcut>segtreerpc</Shortcut>
      <Description>区間更新一点取得(可換作用)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class SegmentTree&lt;T&gt;
{
    public readonly int Size;
    T[] Operators;
    Func&lt;T, T, T&gt; Merge;
    int LeafCount;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SegmentTree(int size, T identity, Func&lt;T, T, T&gt; merge)
    {
        Size = size;
        Merge = merge;
        LeafCount = 1;
        while (LeafCount &lt; size) LeafCount &lt;&lt;= 1;
        Operators = new T[LeafCount &lt;&lt; 1];
        for (int i = 0; i &lt; Operators.Length; i++)
            Operators[i] = identity;
    }
    public T this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return Query(index); }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Operate(int i, T x) { i += LeafCount; Operators[i] = Merge(Operators[i], x); }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Operate(int l, int r, T x)
    {
        for (l += LeafCount, r += LeafCount; l &lt;= r; l = (l + 1) &gt;&gt; 1, r = (r - 1) &gt;&gt; 1)
        {
            if ((l &amp; 1) == 1) Operators[l] = Merge(Operators[l], x);
            if ((r &amp; 1) == 0) Operators[r] = Merge(Operators[r], x);
        }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T Query(int i)
    {
        i += LeafCount;
        T res = Operators[i];
        while (0 &lt; (i &gt;&gt;= 1)) res = Merge(res, Operators[i]);
        return res;
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>SegmentTree(Range Update/Point Query, Non-Commutative operation)</Title>
      <Shortcut>segtreerpnc</Shortcut>
      <Description>区間更新一点取得(非可換作用)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class SegmentTree&lt;T&gt;
{
    public readonly int Size;
    T Identity;
    Func&lt;T, T, T&gt; Merge;
    int LeafCount;
    int Height;
    T[] Operators;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SegmentTree(int size, T identity, Func&lt;T, T, T&gt; merge)
    {
        Size = size;
        Identity = identity;
        Merge = merge;
        Height = 1;
        LeafCount = 1;
        while (LeafCount &lt; size) { Height++; LeafCount &lt;&lt;= 1; }
        Operators = new T[LeafCount &lt;&lt; 1];
        for (int i = 0; i &lt; Operators.Length; i++) Operators[i] = identity;
    }

    public T this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return Query(index); }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { Propagate(index += LeafCount); Operators[index] = value; }
    }


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Operate(int i, T x) { Propagate(i += LeafCount); Operators[i] = Merge(Operators[i], x); }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Operate(int l, int r, T x)
    {
        l += LeafCount;
        r += LeafCount;
        Propagate(l);
        Propagate(r);
        while (l &lt;= r)
        {
            if ((l &amp; 1) == 1) Operators[l] = Merge(Operators[l], x);
            if ((r &amp; 1) == 0) Operators[r] = Merge(Operators[r], x);
            l = (l + 1) / 2;
            r = (r - 1) / 2;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T Query(int index)
    {
        index += LeafCount;
        Propagate(index);
        return Operators[index];
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Propagate(int sectionIndex)
    {
        for (int i = Height - 1; i &gt;= 1; i--)
        {
            var section = sectionIndex &gt;&gt; i;
            var leftChild = sectionIndex &gt;&gt; (i - 1);
            var rightChild = leftChild ^ 1;
            Operators[leftChild] = Merge(Operators[leftChild], Operators[section]);
            Operators[rightChild] = Merge(Operators[rightChild], Operators[section]);
            Operators[section] = Identity;
        }
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>SegmentTree(Range Update/Range Query, Commutative operation)</Title>
      <Shortcut>segtreerrc</Shortcut>
      <Description>区間更新区間取得(可換作用)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class SegmentTree&lt;DataT, OperatorT&gt;
{
    public readonly int Size;
    DataT DataIdentity;
    OperatorT OperatorIdentity;
    Func&lt;DataT, DataT, DataT&gt; MergeData;
    Func&lt;OperatorT, OperatorT, OperatorT&gt; MergeOperator;
    Func&lt;DataT, OperatorT, DataT&gt; Operate;
    int LeafCount;
    int Height;
    DataT[] Data;
    OperatorT[] Operators;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SegmentTree(int size, DataT dataIdentity, OperatorT operatorIdentity, Func&lt;DataT, DataT, DataT&gt; mergeData, Func&lt;OperatorT, OperatorT, OperatorT&gt; mergeOpeator, Func&lt;DataT, OperatorT, DataT&gt; operate)
        : this(dataIdentity, operatorIdentity, mergeData, mergeOpeator, operate)
    {
        Size = size;
        Build();
        for (int i = 0; i &lt; Data.Length; i++) Data[i] = DataIdentity;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SegmentTree(DataT[] data, DataT dataIdentity, OperatorT operatorIdentity, Func&lt;DataT, DataT, DataT&gt; mergeData, Func&lt;OperatorT, OperatorT, OperatorT&gt; mergeOpeator, Func&lt;DataT, OperatorT, DataT&gt; operate)
        : this(dataIdentity, operatorIdentity, mergeData, mergeOpeator, operate)
    {
        Size = data.Length;
        Build();
        for (int i = 0; i &lt; data.Length; i++) Data[i + LeafCount] = data[i];
        for (int i = data.Length + LeafCount; i &lt; Data.Length; i++) Data[i] = dataIdentity;
        for (int i = LeafCount - 1; i &gt;= 0; i--) Data[i] = MergeData(Data[i &lt;&lt; 1], Data[(i &lt;&lt; 1) + 1]);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private SegmentTree(DataT dataIdentity, OperatorT operatorIdentity, Func&lt;DataT, DataT, DataT&gt; mergeData, Func&lt;OperatorT, OperatorT, OperatorT&gt; mergeOpeator, Func&lt;DataT, OperatorT, DataT&gt; operate)
    {
        DataIdentity = dataIdentity;
        OperatorIdentity = operatorIdentity;
        MergeData = mergeData;
        MergeOperator = mergeOpeator;
        Operate = operate;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Build()
    {
        Height = 1;
        LeafCount = 1;
        while (LeafCount &lt; Size) { Height++; LeafCount &lt;&lt;= 1; }
        Operators = new OperatorT[LeafCount &lt;&lt; 1];
        for (int i = 0; i &lt; Operators.Length; i++) Operators[i] = OperatorIdentity;
        Data = new DataT[LeafCount &lt;&lt; 1];
    }
    public DataT this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { Propagate(index + LeafCount); return Reflect(index); }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { Propagate(index += LeafCount); Data[index] = value; Operators[index] = OperatorIdentity; Calculate(index, index); }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Update(int l, int r, OperatorT x)
    {
        l += LeafCount;
        r += LeafCount;
        int origL = l, origR = r;
        while (l &lt;= r)
        {
            if ((l &amp; 1) == 1) Operators[l] = MergeOperator(Operators[l], x);
            if ((r &amp; 1) == 0) Operators[r] = MergeOperator(Operators[r], x);
            l = (l + 1) &gt;&gt; 1; r = (r - 1) &gt;&gt; 1;
        }
        Calculate(origL, origR);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public DataT Query(int l, int r)
    {
        l += LeafCount;
        r += LeafCount;
        DataT lRes = DataIdentity, rRes = DataIdentity;
        Propagate(l, r);
        while (l &lt;= r)
        {
            if ((l &amp; 1) == 1) lRes = MergeData(lRes, Reflect(l));
            if ((r &amp; 1) == 0) rRes = MergeData(Reflect(r), rRes);
            l = (l + 1) &gt;&gt; 1; r = (r - 1) &gt;&gt; 1;
        }
        return MergeData(lRes, rRes);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Propagate(int ind) { for (int i = Height - 1; i &gt;= 1; i--) { Eval(ind &gt;&gt; i); } return; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Propagate(int l, int r)
    {
        if (l == r) { Propagate(l); return; }
        int xor = l ^ r, i = Height - 1;
        for (; (xor &gt;&gt; i) == 0; i--) { Eval(l &gt;&gt; i); }
        for (; i &gt;= 1; i--) { Eval(l &gt;&gt; i); Eval(r &gt;&gt; i); }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private DataT Reflect(int ind) { return Operate(Data[ind], Operators[ind]); }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Eval(int ind)
    {
        int l = ind &lt;&lt; 1, r = ind &lt;&lt; 1 | 1;
        Operators[l] = MergeOperator(Operators[l], Operators[ind]);
        Operators[r] = MergeOperator(Operators[r], Operators[ind]);
        Data[ind] = Reflect(ind);
        Operators[ind] = OperatorIdentity;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Calculate(int l, int r)
    {
        var xor = l ^ r;
        while (xor &gt; 1) { xor &gt;&gt;= 1; l &gt;&gt;= 1; r &gt;&gt;= 1; Data[l] = MergeData(Reflect(l &lt;&lt; 1), Reflect((l &lt;&lt; 1) | 1)); Data[r] = MergeData(Reflect(r &lt;&lt; 1), Reflect((r &lt;&lt; 1) | 1)); }
        while (l &gt; 1) { l &gt;&gt;= 1; Data[l] = MergeData(Reflect(l &lt;&lt; 1), Reflect((l &lt;&lt; 1) | 1)); }
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>SegmentTree(Range Update/Range Query, Non-Commutative operation)</Title>
      <Shortcut>segtreerrnc</Shortcut>
      <Description>区間更新区間取得(非可換作用)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class SegmentTree&lt;DataT, OperatorT&gt;
{
    public readonly int Size;
    DataT DataIdentity;
    OperatorT OperatorIdentity;
    Func&lt;DataT, DataT, DataT&gt; MergeData;
    Func&lt;OperatorT, OperatorT, OperatorT&gt; MergeOperator;
    Func&lt;DataT, OperatorT, DataT&gt; Operate;
    int LeafCount;
    int Height;
    DataT[] Data;
    OperatorT[] Operators;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SegmentTree(int size, DataT dataIdentity, OperatorT operatorIdentity, Func&lt;DataT, DataT, DataT&gt; mergeData, Func&lt;OperatorT, OperatorT, OperatorT&gt; mergeOpeator, Func&lt;DataT, OperatorT, DataT&gt; operate)
        : this(dataIdentity, operatorIdentity, mergeData, mergeOpeator, operate)
    {
        Size = size;
        Build();
        for (int i = 0; i &lt; Data.Length; i++) Data[i] = DataIdentity;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public SegmentTree(DataT[] data, DataT dataIdentity, OperatorT operatorIdentity, Func&lt;DataT, DataT, DataT&gt; mergeData, Func&lt;OperatorT, OperatorT, OperatorT&gt; mergeOpeator, Func&lt;DataT, OperatorT, DataT&gt; operate)
        : this(dataIdentity, operatorIdentity, mergeData, mergeOpeator, operate)
    {
        Size = data.Length;
        Build();
        for (int i = 0; i &lt; data.Length; i++) Data[i + LeafCount] = data[i];
        for (int i = data.Length + LeafCount; i &lt; Data.Length; i++) Data[i] = dataIdentity;
        for (int i = LeafCount - 1; i &gt;= 0; i--) Data[i] = MergeData(Data[i &lt;&lt; 1], Data[(i &lt;&lt; 1) + 1]);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private SegmentTree(DataT dataIdentity, OperatorT operatorIdentity, Func&lt;DataT, DataT, DataT&gt; mergeData, Func&lt;OperatorT, OperatorT, OperatorT&gt; mergeOpeator, Func&lt;DataT, OperatorT, DataT&gt; operate)
    {
        DataIdentity = dataIdentity;
        OperatorIdentity = operatorIdentity;
        MergeData = mergeData;
        MergeOperator = mergeOpeator;
        Operate = operate;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Build()
    {
        Height = 1;
        LeafCount = 1;
        while (LeafCount &lt; Size) { Height++; LeafCount &lt;&lt;= 1; }
        Operators = new OperatorT[LeafCount &lt;&lt; 1];
        for (int i = 0; i &lt; Operators.Length; i++) Operators[i] = OperatorIdentity;
        Data = new DataT[LeafCount &lt;&lt; 1];
    }
    public DataT this[int index]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { Propagate(index + LeafCount); return Reflect(index); }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { Propagate(index += LeafCount); Data[index] = value; Operators[index] = OperatorIdentity; Calculate(index, index); }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Update(int l, int r, OperatorT x)
    {
        l += LeafCount;
        r += LeafCount;
        int origL = l, origR = r;
        Propagate(l, r);
        while (l &lt;= r)
        {
            if ((l &amp; 1) == 1) Operators[l] = MergeOperator(Operators[l], x);
            if ((r &amp; 1) == 0) Operators[r] = MergeOperator(Operators[r], x);
            l = (l + 1) &gt;&gt; 1; r = (r - 1) &gt;&gt; 1;
        }
        Calculate(origL, origR);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public DataT Query(int l, int r)
    {
        l += LeafCount;
        r += LeafCount;
        DataT lRes = DataIdentity, rRes = DataIdentity;
        Propagate(l, r);
        while (l &lt;= r)
        {
            if ((l &amp; 1) == 1) lRes = MergeData(lRes, Reflect(l));
            if ((r &amp; 1) == 0) rRes = MergeData(Reflect(r), rRes);
            l = (l + 1) &gt;&gt; 1; r = (r - 1) &gt;&gt; 1;
        }
        return MergeData(lRes, rRes);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Propagate(int ind) { for (int i = Height - 1; i &gt;= 1; i--) { Eval(ind &gt;&gt; i); } return; }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Propagate(int l, int r)
    {
        if (l == r) { Propagate(l); return; }
        int xor = l ^ r, i = Height - 1;
        for (; (xor &gt;&gt; i) == 0; i--) { Eval(l &gt;&gt; i); }
        for (; i &gt;= 1; i--) { Eval(l &gt;&gt; i); Eval(r &gt;&gt; i); }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private DataT Reflect(int ind) { return Operate(Data[ind], Operators[ind]); }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Eval(int ind)
    {
        int l = ind &lt;&lt; 1, r = ind &lt;&lt; 1 | 1;
        Operators[l] = MergeOperator(Operators[l], Operators[ind]);
        Operators[r] = MergeOperator(Operators[r], Operators[ind]);
        Data[ind] = Reflect(ind);
        Operators[ind] = OperatorIdentity;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private void Calculate(int l, int r)
    {
        var xor = l ^ r;
        while (xor &gt; 1) { xor &gt;&gt;= 1; l &gt;&gt;= 1; r &gt;&gt;= 1; Data[l] = MergeData(Reflect(l &lt;&lt; 1), Reflect((l &lt;&lt; 1) | 1)); Data[r] = MergeData(Reflect(r &lt;&lt; 1), Reflect((r &lt;&lt; 1) | 1)); }
        while (l &gt; 1) { l &gt;&gt;= 1; Data[l] = MergeData(Reflect(l &lt;&lt; 1), Reflect((l &lt;&lt; 1) | 1)); }
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>PartialPersistentUnionFind</Title>
      <Shortcut>ppuf</Shortcut>
      <Description>部分永続Union-Find</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class PartialPersistentUnionFind
{
    const int MAX = 1 &lt;&lt; 30;
    public readonly int Size;
    public int Now { get; private set; }
    public IEnumerable&lt;int&gt; AllRepresents =&gt; Parents.Where((x, y) =&gt; x == y);
    int[] Parents;
    int[] Time;
    int[] Sizes;
    List&lt;int&gt;[] SizeHistories;
    List&lt;int&gt;[] TimeStamps;

    public PartialPersistentUnionFind(int size)
    {
        Size = size;
        Parents = new int[size];
        Time = new int[size];
        Sizes = new int[size];
        SizeHistories = new List&lt;int&gt;[size];
        TimeStamps = new List&lt;int&gt;[size];
        for (int i = 0; i &lt; Size; i++)
        {
            Time[i] = MAX;
            Sizes[i] = 1;
            SizeHistories[i] = new List&lt;int&gt;() { 1 };
            TimeStamps[i] = new List&lt;int&gt;() { 0 };
        }
    }

    public bool TryUnite(int x, int y)
    {
        Now++;
        x = Find(x);
        y = Find(y);
        if (x == y) return false;
        if (Sizes[x] &lt; Sizes[y]) { var tmp = x; x = y; y = tmp; }
        Time[y] = Now;
        Parents[y] = x;
        Sizes[x] += Sizes[y];
        TimeStamps[x].Add(Now &lt;&lt; 1);
        SizeHistories[x].Add(Sizes[x]);
        return true;
    }
    public int Find(int i, int t = MAX)
    {
        while (Time[i] &lt;= t) i = Parents[i];
        return i;
    }
    public int GetSize(int i, int t = MAX)
    {
        var root = Find(i, t);
        return SizeHistories[root][~TimeStamps[root].BinarySearch(t &lt;&lt; 1 | 1) - 1];
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>PotentializedUnionFind</Title>
      <Shortcut>puf</Shortcut>
      <Description>ポテンシャル付き素集合データ構造</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class PotentializedUnionFind&lt;T&gt; where T : IEquatable&lt;T&gt;
{
    public int Size { get; private set; }
    public int GroupCount { get; private set; }
    public IEnumerable&lt;int&gt; AllRepresents =&gt; Parent.Where((x, y) =&gt; x == y);
    int[] Sizes;
    int[] Parent;
    T[] Value;
    Func&lt;T, T, T&gt; Operate;
    Func&lt;T, T&gt; Inverse;
    T Identity;

    public PotentializedUnionFind(int count, Func&lt;T, T, T&gt; operate, Func&lt;T, T&gt; inverse, T identity)
    {
        Size = count;
        GroupCount = count;
        Parent = new int[count];
        Sizes = new int[count];
        Value = new T[count];
        for (int i = 0; i &lt; count; i++) { Sizes[Parent[i] = i] = 1; Value[i] = identity; }
        Operate = operate;
        Inverse = inverse;
        Identity = identity;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public bool TryUnite(int x, int y, T distance)
    {
        T xd, yd;
        int xp = Find(x, out xd);
        int yp = Find(y, out yd);

        if (yp == xp) return Operate(distance, yd).Equals(xd);

        GroupCount--;
        if (Sizes[xp] &lt; Sizes[yp])
        {
            Value[xp] = Operate(Operate(Inverse(xd), distance), yd);
            Parent[xp] = yp;
            Sizes[yp] += Sizes[xp];
        }
        else
        {
            Value[yp] = Operate(Operate(Inverse(yd), Inverse(distance)), xd);
            Parent[yp] = xp;
            Sizes[xp] += Sizes[yp];
        }
        return true;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int GetSize(int x) =&gt; Sizes[Find(x)];

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public T GetPotential(int x, int y)
    {
        T xd, yd;
        int xp = Find(x, out xd);
        int yp = Find(y, out yd);
        if (yp == xp) return Operate(Inverse(xd), yd);
        else return Identity;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Find(int x)
    {
        while (x != Parent[x]) { Value[x] = Operate(Value[x], Value[Parent[x]]); Parent[x] = Parent[Parent[x]]; x = Parent[x]; }
        return x;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private int Find(int x, out T potential)
    {
        potential = Identity;
        while (x != Parent[x])
        {
            Value[x] = Operate(Value[x], Value[Parent[x]]);
            Parent[x] = Parent[Parent[x]];
            potential = Operate(potential, Value[x]);
            x = Parent[x];
        }
        return x;
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>UnionFind with Data</Title>
      <Shortcut>ufd</Shortcut>
      <Description>データ保持可能Union-Find</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class UnionFind&lt;T&gt;
{
    public readonly int Size;
    public int GroupCount { get; private set; }
    public IEnumerable&lt;int&gt; AllRepresents =&gt; Parent.Where((x, y) =&gt; x == y);
    int[] Sizes;
    int[] Parent;
    T[] Data;
    Func&lt;T, T, T&gt; MergeData;
    public UnionFind(int count)
    {
        Size = count;
        GroupCount = count;
        Parent = new int[count];
        Sizes = new int[count];
        Data = new T[count];
        for (int i = 0; i &lt; count; i++)
        {
            Parent[i] = i;
            Sizes[i] = 1;
            Data[i] = default(T);
        }
    }
    public T this[int index]
    {
        get { return Data[Find(index)]; }
        set { Data[Find(index)] = value; }
    }

    public bool TryUnite(int x, int y)
    {
        int xp = Find(x);
        int yp = Find(y);
        if (yp == xp) return false;
        if (Sizes[xp] &lt; Sizes[yp])
        {
            var tmp = xp;
            xp = yp;
            yp = tmp;
        }
        GroupCount--;
        Parent[yp] = xp;
        Data[xp] = MergeData(Data[xp], Data[yp]);
        Sizes[xp] += Sizes[yp];
        return true;
    }
    public int GetSize(int x) =&gt; Sizes[Find(x)];
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Find(int x)
    {
        while (x != Parent[x])
        {
            Parent[x] = Parent[Parent[x]];
            x = Parent[x];
        }
        return x;
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>UnionFind</Title>
      <Shortcut>uf</Shortcut>
      <Description>素集合データ構造</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class UnionFind
{
    public int Size { get; private set; }
    public int GroupCount { get; private set; }
    public IEnumerable&lt;int&gt; AllRepresents =&gt; Parent.Where((x, y) =&gt; x == y);
    int[] Sizes;
    int[] Parent;
    public UnionFind(int count)
    {
        Size = count;
        GroupCount = count;
        Parent = new int[count];
        Sizes = new int[count];
        for (int i = 0; i &lt; count; i++) Sizes[Parent[i] = i] = 1;
    }
    public bool TryUnite(int x, int y)
    {
        int xp = Find(x);
        int yp = Find(y);
        if (yp == xp) return false;
        if (Sizes[xp] &lt; Sizes[yp]) { var tmp = xp; xp = yp; yp = tmp; }
        GroupCount--;
        Parent[yp] = xp;
        Sizes[xp] += Sizes[yp];
        return true;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int GetSize(int x) =&gt; Sizes[Find(x)];
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public int Find(int x)
    {
        while (x != Parent[x]) x = (Parent[x] = Parent[Parent[x]]);
        return x;
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Wavelet Matrix</Title>
      <Shortcut>wm</Shortcut>
      <Description>Wavlet Matrixのコンストラクタ</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">class WaveletMatrix
{
    public int Length { get; private set; }
    public int Max { get; private set; }
    int Depth;
    BitVector[] BitVectors;
    int[] ZeroCount;
    int[] BlockStartIndex;

    public WaveletMatrix(int[] elem, int max)
    {
        Max = max;
        Length = elem.Length;
        Depth = MSBPos(max) + 1;
        BitVectors = new BitVector[Depth];
        ZeroCount = new int[Depth];
        BlockStartIndex = new int[max + 1];

        for (int i = 0; i &lt; elem.Length; i++)
            for (int j = 0; j &lt; Depth; j++)
                if ((elem[i] &amp; (1 &lt;&lt; j)) == 0) ZeroCount[j]++;

        elem = elem.ToArray();
        bool[] bits = new bool[Length + 1];
        int[] buf = new int[Length];
        for (int i = Depth - 1; i &gt;= 0; i--)
        {
            int[] newElem = buf;
            int mask = 1 &lt;&lt; i;
            int index0 = 0;
            int index1 = ZeroCount[i];
            for (int j = 0; j &lt; elem.Length;)
            {
                if ((elem[j] &amp; mask) == 0)
                {
                    bits[j] = false;
                    newElem[index0++] = elem[j++];
                }
                else
                {
                    bits[j] = true;
                    newElem[index1++] = elem[j++];
                }
            }
            BitVectors[i] = new BitVector(bits);
            buf = elem;
            elem = newElem;
        }
        int ptr;
        int[] reversedSequence = new int[] { 0 };
        for (int i = 1; i &lt;= Depth; i++)
        {
            var newReversedSequence = new int[1 &lt;&lt; i];
            var mask = 1 &lt;&lt; (i - 1);
            ptr = 0;
            for (int j = 0; j &lt; reversedSequence.Length; j++)
            {
                newReversedSequence[ptr++] = reversedSequence[j];
                newReversedSequence[ptr++] = reversedSequence[j] | mask;
            }
            reversedSequence = newReversedSequence;
        }
        ptr = 0;
        for (int i = 0; i &lt; reversedSequence.Length; i++)
        {
            BlockStartIndex[reversedSequence[i]] = ptr;
            while (ptr &lt; elem.Length &amp;&amp; elem[ptr] == reversedSequence[i]) ptr++;
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    static int MSBPos(int n)
    {
        int res = 0;
        if (0 != (n &gt;&gt; (res | 16))) res |= 16;
        if (0 != (n &gt;&gt; (res | 8))) res |= 8;
        if (0 != (n &gt;&gt; (res | 4))) res |= 4;
        if (0 != (n &gt;&gt; (res | 2))) res |= 2;
        if (0 != (n &gt;&gt; (res | 1))) res |= 1;
        return res;
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Quantile</Title>
      <Shortcut>wmquantile</Shortcut>
      <Description>[start, end)のうちk番目に大きい数を返す</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">[MethodImpl(MethodImplOptions.AggressiveInlining)]
public int Quantile(int start, int end, int k)
{
    int res = 0;
    for (int i = Depth - 1; i &gt;= 0; i--)
    {
        var startRank = BitVectors[i].Rank(start);
        var endRank = BitVectors[i].Rank(end);
        var oneCount = endRank - startRank;
        if (oneCount &lt;= k)
        {
            k -= oneCount;
            start -= startRank;
            end -= endRank;
        }
        else
        {
            res |= 1 &lt;&lt; i;
            start = ZeroCount[i] + startRank;
            end = ZeroCount[i] + endRank;
        }
    }
    return res;
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Rank([0, end))</Title>
      <Shortcut>wmranksf</Shortcut>
      <Description>[0, end)に含まれるkindの個数を返す</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">[MethodImpl(MethodImplOptions.AggressiveInlining)]
public int Rank(int end, int kind)
{
    for (int i = Depth - 1; i &gt;= 0; i--)
    {
        bool param = (kind &amp; (1 &lt;&lt; i)) != 0;
        end = BitVectors[i].Rank(end, param);
        if (param) end += ZeroCount[i];
    }
    return end - BlockStartIndex[kind];
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Rank([start, end))</Title>
      <Shortcut>wmrank</Shortcut>
      <Description>[start, end)に含まれるkindの個数を返す</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">[MethodImpl(MethodImplOptions.AggressiveInlining)]
public int Rank(int start, int end, int kind)
{
    for (int i = Depth - 1; i &gt;= 0; i--)
    {
        bool param = (kind &amp; (1 &lt;&lt; i)) != 0;
        start = BitVectors[i].Rank(start, param);
        end = BitVectors[i].Rank(end, param);
        if (param) { start += ZeroCount[i]; end += ZeroCount[i]; }
    }
    return end - start;
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Select</Title>
      <Shortcut>wmselect</Shortcut>
      <Description>k番目に登場するkindのindexを返す</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">[MethodImpl(MethodImplOptions.AggressiveInlining)]
public int Select(int k, int kind)
{
    var place = BlockStartIndex[kind] + k;
    for (int i = 0; i &lt; Depth; i++)
    {
        bool param = (kind &amp; (1 &lt;&lt; i)) != 0;
        if (param) place = BitVectors[i].Select1(place - ZeroCount[i]);
        else place = BitVectors[i].Select0(place);
    }
    return place;
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>WriteLine(Multi Line)</Title>
      <Shortcut>cwl</Shortcut>
      <Description>複数行に出力</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>collection</ID>
          <Default>collection</Default>
          <ToolTip>コレクション</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">Console.WriteLine(string.Join("\n", $collection$));</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>WriteLine(Multi Line/Splitted)</Title>
      <Shortcut>cwls</Shortcut>
      <Description>空白区切りで複数行に出力</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>collection</ID>
          <Default>collection</Default>
          <ToolTip>コレクション</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">Console.WriteLine(string.Join("\n", $collection$.Select(x =&gt; string.Join(" ", x))));</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>WriteLine(Splitted)</Title>
      <Shortcut>cws</Shortcut>
      <Description>空白区切りで出力</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>collection</ID>
          <Default>collection</Default>
          <ToolTip>コレクション</ToolTip>
        </Literal>
        <Literal>
          <ID>separator</ID>
          <Default>" "</Default>
          <ToolTip>区切り文字</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">Console.WriteLine(string.Join($separator$, $collection$));</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>WriteLine(Yes/No)</Title>
      <Shortcut>cwyn</Shortcut>
      <Description>Yes/Noを出力</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>cond</ID>
          <Default>cond</Default>
          <ToolTip>条件</ToolTip>
        </Literal>
        <Literal>
          <ID>yes</ID>
          <Default>"Yes"</Default>
          <ToolTip>yes</ToolTip>
        </Literal>
        <Literal>
          <ID>no</ID>
          <Default>"No"</Default>
          <ToolTip>no</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">Console.WriteLine($cond$ ? $yes$ : $no$);</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Reader Core</Title>
      <Shortcut>reader</Shortcut>
      <Description>各種Readerを格納するためのclass</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.IO</Namespace>
        </Import>
        <Import>
          <Namespace>static Reader</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">static class Reader
{
    const int BUF_SIZE = 1 &lt;&lt; 12;
    static Stream Stream = Console.OpenStandardInput();
    static byte[] Buffer = new byte[BUF_SIZE];
    static int ptr = BUF_SIZE - 1;
    static void Move() { if (++ptr &gt;= Buffer.Length) { Stream.Read(Buffer, 0, BUF_SIZE); ptr = 0; } }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Signed Integer Reader</Title>
      <Shortcut>sreader</Shortcut>
      <Description>符号付き整数を読み込む</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>T</ID>
          <Default>int</Default>
          <ToolTip>型</ToolTip>
        </Literal>
        <Literal>
          <ID>Name</ID>
          <Default>Int</Default>
          <ToolTip />
        </Literal>
      </Declarations>
      <Code Language="CSharp">public static $T$ Next$Name$
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    get
    {
        $T$ res = 0; int sign = 1; while (Buffer[ptr] &lt; 45) Move();
        if (Buffer[ptr] == 45) { Move(); sign = -1; }
        do { res = res * 10 + (Buffer[ptr] ^ 48); Move(); } while (48 &lt;= Buffer[ptr]);
        return res * sign;
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Unsigned Integer Reader</Title>
      <Shortcut>ureader</Shortcut>
      <Description>符号なし整数を読み込む</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>T</ID>
          <Default>uint</Default>
          <ToolTip>型</ToolTip>
        </Literal>
        <Literal>
          <ID>Name</ID>
          <Default>UInt</Default>
          <ToolTip />
        </Literal>
      </Declarations>
      <Code Language="CSharp">public static $T$ Next$Name$
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    get
    {
        $T$ res = 0; while (Buffer[ptr] &lt; 48) Move();
        do { res = res * 10 + ($T$)(Buffer[ptr] ^ 48); Move(); } while (48 &lt;= Buffer[ptr]);
        return res;
    }
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Derangement Number</Title>
      <Shortcut>derangement</Shortcut>
      <Description>攪乱順列</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Code Language="CSharp">static ModInt DerangementNumber(int n)
{
    ModInt res = 0;
    var factorialN = Factorial(n);
    for (int i = 2; i &lt;= n; i++)
    {
        if ((i &amp; 1) == 0) res += factorialN / Factorial(i);
        else res -= factorialN / Factorial(i);
    }
    return res;
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Factorial</Title>
      <Shortcut>factorial</Shortcut>
      <Description>階乗</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">static List&lt;ModInt&gt; factorialMemo = new List&lt;ModInt&gt;() { 1 };
static ModInt Factorial(int x)
{
    for (int i = factorialMemo.Count; i &lt;= x; i++) factorialMemo.Add(factorialMemo.Last() * i);
    return factorialMemo[x];
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>1e9+7</Title>
      <Shortcut>mod</Shortcut>
      <Description>1000000007</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Code Language="CSharp">1000000007</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>998244353</Title>
      <Shortcut>mod</Shortcut>
      <Description>998244353</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Code Language="CSharp">998244353</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>Matrix</Title>
      <Shortcut>matrix</Shortcut>
      <Description>行列</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions</Namespace>
        </Import>
        <Import>
          <Namespace>MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>T</ID>
          <Default>ModInt</Default>
          <ToolTip>環</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">class Matrix
{
    public readonly int Height;
    public readonly int Width;
    $T$[] data;
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Matrix(int height, int width)
    {
        data = new $T$[height * width];
        Height = height;
        Width = width;
    }
    public $T$ this[int i, int j]
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get { return data[i * Width + j]; }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        set { data[i * Width + j] = value; }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Matrix Add(Matrix a, Matrix b)
    {
        var res = new Matrix(a.Height, a.Width);
        for (int i = 0; i &lt; a.Height; i++) for (int j = 0; j &lt; a.Width; j++) res[i, j] = a[i, j] + b[i, j];
        return res;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Matrix Sub(Matrix a, Matrix b)
    {
        var res = new Matrix(a.Height, a.Width);
        for (int i = 0; i &lt; a.Height; i++) for (int j = 0; j &lt; a.Width; j++) res[i, j] = a[i, j] - b[i, j];
        return res;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Matrix Mul(Matrix a, Matrix b)
    {
        var res = new Matrix(a.Height, b.Width);
        for (int i = 0; i &lt; a.Height; i++) for (int j = 0; j &lt; b.Width; j++) for (int k = 0; k &lt; a.Width; k++) res[i, j] += a[i, k] * b[k, j];
        return res;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Matrix operator +(Matrix a, Matrix b) =&gt; Add(a, b);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Matrix operator -(Matrix a, Matrix b) =&gt; Sub(a, b);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static Matrix operator *(Matrix a, Matrix b) =&gt; Mul(a, b);
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadGraphDirected</Title>
      <Shortcut>rgd</Shortcut>
      <Description>有向グラフの読み込み</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>graph</ID>
          <Default>graph</Default>
          <ToolTip>変数</ToolTip>
        </Literal>
        <Literal>
          <ID>n</ID>
          <Default>n</Default>
          <ToolTip>頂点数</ToolTip>
        </Literal>
        <Literal>
          <ID>m</ID>
          <Default>m</Default>
          <ToolTip>辺数</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">List&lt;int&gt;[] $graph$ = Enumerable.Repeat(0, $n$).Select(_ =&gt; new List&lt;int&gt;()).ToArray();
for (int i = 0; i &lt; $m$; i++)
{
    var st = Console.ReadLine().Split().Select(x =&gt; int.Parse(x) - 1).ToArray();
    $graph$[st[0]].Add(st[1]);
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadGraphUnDirected</Title>
      <Shortcut>rgud</Shortcut>
      <Description>無向グラフの読み込み</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
        <Import>
          <Namespace>System.Collections.Generic</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>graph</ID>
          <Default>graph</Default>
          <ToolTip>変数</ToolTip>
        </Literal>
        <Literal>
          <ID>n</ID>
          <Default>n</Default>
          <ToolTip>頂点数</ToolTip>
        </Literal>
        <Literal>
          <ID>m</ID>
          <Default>m</Default>
          <ToolTip>辺数</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">List&lt;int&gt;[] $graph$ = Enumerable.Repeat(0, $n$).Select(_ =&gt; new List&lt;int&gt;()).ToArray();
for (int i = 0; i &lt; $m$; i++)
{
    var st = Console.ReadLine().Split().Select(x =&gt; int.Parse(x) - 1).ToArray();
    $graph$[st[0]].Add(st[1]);
    $graph$[st[1]].Add(st[0]);
}</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadLineDouble</Title>
      <Shortcut>rldouble</Shortcut>
      <Description>複数行単一データの読み込み(double型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>n</ID>
          <Default>n</Default>
          <ToolTip>行数</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">Enumerable.Repeat(0, $n$).Select(_ =&gt; double.Parse(Console.ReadLine())).ToArray()</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadLineInt</Title>
      <Shortcut>rlint</Shortcut>
      <Description>複数行単一データの読み込み(int型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>n</ID>
          <Default>n</Default>
          <ToolTip>行数</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">Enumerable.Repeat(0, $n$).Select(_ =&gt; int.Parse(Console.ReadLine())).ToArray()</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadLineLong</Title>
      <Shortcut>rllong</Shortcut>
      <Description>複数行単一データの読み込み(long型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>n</ID>
          <Default>n</Default>
          <ToolTip>行数</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">Enumerable.Repeat(0, $n$).Select(_ =&gt; long.Parse(Console.ReadLine())).ToArray()</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadLineString</Title>
      <Shortcut>rlstr</Shortcut>
      <Description>複数行単一データの読み込み(string型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>n</ID>
          <Default>n</Default>
          <ToolTip>行数</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">Enumerable.Repeat(0, $n$).Select(_ =&gt; Console.ReadLine()).ToArray()</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadLineSplitDouble</Title>
      <Shortcut>rlsdouble</Shortcut>
      <Description>複数行複数データの読み込み(double型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>n</ID>
          <Default>n</Default>
          <ToolTip>行数</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">Enumerable.Repeat(0, $n$).Select(_ =&gt; Console.ReadLine().Split().Select(double.Parse).ToArray()).ToArray()</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadLineSplitInt</Title>
      <Shortcut>rlsint</Shortcut>
      <Description>複数行複数データの読み込み(int型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>n</ID>
          <Default>n</Default>
          <ToolTip>行数</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">Enumerable.Repeat(0, $n$).Select(_ =&gt; Console.ReadLine().Split().Select(int.Parse).ToArray()).ToArray()</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadLineSplitLong</Title>
      <Shortcut>rlslong</Shortcut>
      <Description>複数行複数データの読み込み(long型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>n</ID>
          <Default>n</Default>
          <ToolTip>行数</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">Enumerable.Repeat(0, $n$).Select(_ =&gt; Console.ReadLine().Split().Select(long.Parse).ToArray()).ToArray()</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadLineSplitString</Title>
      <Shortcut>rlsstr</Shortcut>
      <Description>複数行複数データの読み込み(string型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
      </Imports>
      <Declarations>
        <Literal>
          <ID>n</ID>
          <Default>n</Default>
          <ToolTip>行数</ToolTip>
        </Literal>
      </Declarations>
      <Code Language="CSharp">Enumerable.Repeat(0, $n$).Select(_ =&gt; Console.ReadLine().Split()).ToArray()</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadDouble</Title>
      <Shortcut>rdouble</Shortcut>
      <Description>単一行単一データの読み込み(double型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">double.Parse(Console.ReadLine())</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadInt</Title>
      <Shortcut>rint</Shortcut>
      <Description>単一行単一データの読み込み(int型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">int.Parse(Console.ReadLine())</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadLong</Title>
      <Shortcut>rlong</Shortcut>
      <Description>単一行単一データの読み込み(long型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">long.Parse(Console.ReadLine())</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadString</Title>
      <Shortcut>rstr</Shortcut>
      <Description>単一行単一データの読み込み(string型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">Console.ReadLine()</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadSplitDouble</Title>
      <Shortcut>rsdouble</Shortcut>
      <Description>単一行複数データの読み込み(double型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">Console.ReadLine().Split().Select(double.Parse).ToArray()</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadSplitInt</Title>
      <Shortcut>rsint</Shortcut>
      <Description>単一行複数データの読み込み(int型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">Console.ReadLine().Split().Select(int.Parse).ToArray()</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadSplitLong</Title>
      <Shortcut>rslong</Shortcut>
      <Description>単一行複数データの読み込み(long型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">Console.ReadLine().Split().Select(long.Parse).ToArray()</Code>
    </Snippet>
  </CodeSnippet>
  <CodeSnippet Format="1.0.0">
    <Header>
      <Title>ReadSplitString</Title>
      <Shortcut>rsstr</Shortcut>
      <Description>単一行複数データの読み込み(string型)</Description>
      <Author>keymoon</Author>
    </Header>
    <Snippet>
      <Imports>
        <Import>
          <Namespace>System</Namespace>
        </Import>
        <Import>
          <Namespace>System.Linq</Namespace>
        </Import>
      </Imports>
      <Code Language="CSharp">Console.ReadLine().Split()</Code>
    </Snippet>
  </CodeSnippet>
</CodeSnippets>